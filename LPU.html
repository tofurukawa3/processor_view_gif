<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>LPU Deterministic Flow Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }

        h2 {
            margin-bottom: 10px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }

        button {
            padding: 10px 20px;
            background: #444;
            color: white;
            border: 1px solid #666;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }

        button.active {
            background: #00d2ff;
            color: #000;
            border-color: #00d2ff;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
            gap: 2px;
            background: #222;
            padding: 10px;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.2);
        }

        .cell {
            width: 30px;
            height: 30px;
            background: #333;
            border-radius: 2px;
            transition: background-color 0.05s linear;
            /* LPUの高速性表現のため遷移時間を短く */
        }

        /* ステータス表示 */
        .status {
            margin-top: 15px;
            font-family: monospace;
            color: #aaa;
        }

        .highlight {
            color: #00d2ff;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h2>LPU Visualization: Deterministic Flow</h2>

    <div class="controls">
        <button id="btn-lpu" class="active" onclick="setMode('lpu')">LPU (Deterministic)</button>
        <button id="btn-trad" onclick="setMode('traditional')">Traditional (With Jitter)</button>
    </div>

    <div class="grid-container" id="grid">
    </div>

    <div class="status">
        Mode: <span id="mode-display" class="highlight">LPU (Groq-like)</span><br>
        Status: <span id="flow-status">Perfect Synchronization</span>
    </div>

    <script>
        const grid = document.getElementById('grid');
        const cells = [];
        const size = 10;
        let mode = 'lpu';
        let tick = 0;

        // グリッド生成
        for (let i = 0; i < size * size; i++) {
            const div = document.createElement('div');
            div.className = 'cell';
            grid.appendChild(div);
            cells.push(div);
        }

        function setMode(newMode) {
            mode = newMode;
            document.getElementById('btn-lpu').className = newMode === 'lpu' ? 'active' : '';
            document.getElementById('btn-trad').className = newMode === 'traditional' ? 'active' : '';
            document.getElementById('mode-display').innerText = newMode === 'lpu' ? 'LPU (Groq-like)' : 'Traditional CPU/GPU';
            document.getElementById('mode-display').style.color = newMode === 'lpu' ? '#00d2ff' : '#ff9900';
        }

        function update() {
            tick++;

            // モードによる挙動の変化
            let stall = false;

            if (mode === 'traditional') {
                // ランダムに「ストール（待機）」を発生させる
                // メモリアクセス待ちやキャッシュミスをシミュレーション
                if (Math.random() < 0.15) {
                    stall = true;
                }
            }

            const statusText = document.getElementById('flow-status');
            if (stall) {
                statusText.innerText = "STALL / Cache Miss...";
                statusText.style.color = "#ff4444";
                // ストール時は画面更新をスキップ（時間が止まる表現）
                requestAnimationFrame(update);
                return;
            } else {
                statusText.innerText = mode === 'lpu' ? "Perfect Synchronization" : "Processing...";
                statusText.style.color = "#aaa";
            }

            // 行列の更新処理
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const index = y * size + x;
                    const cell = cells[index];

                    let brightness = 0;

                    if (mode === 'lpu') {
                        // LPU: 決定論的ストリーム
                        // データは左上から右下へ、またはベクトルとして一斉に流れる
                        // ここでは「ベクトルストリーム」を表現（縦方向の同期した流れ）

                        // 時間(tick)と位置(y)だけで色が完全に決まる = コンパイル時に計算済み
                        // x（列）方向は完全に並列（同じ色）またはわずかにずらしてベクトル処理を表現

                        // 波（Wave）が列ごとに流れる計算
                        const wave = (tick - y) % 15;
                        if (wave >= 0 && wave < 5) {
                            // アクティブなデータパケット (明るいオレンジ/青)
                            brightness = 1 - (wave / 5);
                            cell.style.backgroundColor = `rgba(0, 210, 255, ${brightness})`;
                            cell.style.transform = `scale(${1 + brightness * 0.1})`; // わずかに脈動
                        } else {
                            cell.style.backgroundColor = '#222';
                            cell.style.transform = `scale(1)`;
                        }

                    } else {
                        // Traditional: ランダムアクセス的な処理
                        // スカラ処理やスレッドの非同期性を表現（バラバラに点滅）
                        const randomOffset = Math.floor(Math.random() * 5);
                        const active = (tick + randomOffset) % 20 === 0;

                        if (active) {
                            cell.style.backgroundColor = 'rgba(255, 153, 0, 0.8)';
                        } else {
                            // 残像を残す
                            const current = getComputedStyle(cell).backgroundColor;
                            // 簡易的な減衰処理はCSS transitionに任せる
                            if (current !== 'rgb(34, 34, 34)' && Math.random() > 0.8) {
                                cell.style.backgroundColor = '#222';
                            }
                        }
                        cell.style.transform = `scale(1)`;
                    }
                }
            }

            // LPUは高速なので更新頻度を上げても破綻しないが、視認性のため調整
            setTimeout(() => requestAnimationFrame(update), mode === 'lpu' ? 50 : 80);
        }

        update();

    </script>
</body>

</html>